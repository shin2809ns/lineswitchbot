"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Line = void 0;
const Point_1 = require("./Point");
const mathzz_1 = require("mathzz");
class Line {
    constructor(p1, p2) {
        if (p2 === undefined) {
            this.p1 = new Point_1.Point(p1.p1);
            this.p2 = new Point_1.Point(p1.p2);
        }
        else {
            this.p1 = new Point_1.Point(p1);
            this.p2 = new Point_1.Point(p2);
        }
    }
    get generalForm() {
        const a = this.p1.y - this.p2.y;
        const b = this.p2.x - this.p1.x;
        const c = this.p1.x * this.p2.y - this.p2.x * this.p1.y;
        return [a, b, c];
    }
    lerp(t) {
        return this.p1.lerpTo(this.p2, t);
    }
    rlerp(p) {
        const tx = (0, mathzz_1.rlerp)(this.p1.x, this.p2.x, p.x);
        const ty = (0, mathzz_1.rlerp)(this.p1.y, this.p2.y, p.y);
        if (tx === null || ty === null) {
            return null;
        }
        if (!mathzz_1.TMath.eq(tx, ty)) {
            return null;
        }
        return tx;
    }
    intersectsAt(line) {
        if (!(line instanceof Line)) {
            line = new Line(line.p1, line.p2);
        }
        const [a1, b1, c1] = this.generalForm;
        const [a2, b2, c2] = line.generalForm;
        const det = a1 * b2 - a2 * b1;
        if (mathzz_1.TMath.eq(det, 0)) {
            return null;
        }
        const x = (b1 * c2 - b2 * c1) / det;
        const y = (c1 * a2 - c2 * a1) / det;
        return new Point_1.Point(x, y);
    }
    intersects(line) {
        return !!this.intersectsAt(line);
    }
    intersectsAtTime(line) {
        const intersection = this.intersectsAt(line);
        if (!intersection) {
            return null;
        }
        return this.rlerp(intersection);
    }
    isExtensionOf(line) {
        if (!(line instanceof Line)) {
            line = new Line(line.p1, line.p2);
        }
        const [a1, b1, c1] = this.generalForm;
        const [a2, b2, c2] = line.generalForm;
        return (mathzz_1.TMath.eq(a1 * b2, a2 * b1) &&
            mathzz_1.TMath.eq(a1 * c2, a2 * c1) &&
            mathzz_1.TMath.eq(b1 * c2, b2 * c1));
    }
    isParallelTo(line) {
        if (!(line instanceof Line)) {
            line = new Line(line.p1, line.p2);
        }
        const [a1, b1] = this.generalForm;
        const [a2, b2] = line.generalForm;
        return mathzz_1.TMath.eq(a1 * b2, a2 * b1);
    }
    isPerpendicularTo(line) {
        if (!(line instanceof Line)) {
            line = new Line(line.p1, line.p2);
        }
        const [a1, b1] = this.generalForm;
        const [a2, b2] = line.generalForm;
        return mathzz_1.TMath.eq(a1 * a2, -b1 * b2);
    }
    isCollinearTo(line) {
        if (!(line instanceof Line)) {
            line = new Line(line.p1, line.p2);
        }
        const [a1, b1] = this.generalForm;
        const [a2, b2] = line.generalForm;
        return mathzz_1.TMath.eq(a1 * b2, a2 * b1) && mathzz_1.TMath.eq(a1 * a2, b1 * b2);
    }
    isConcurrentTo(line) {
        if (!(line instanceof Line)) {
            line = new Line(line.p1, line.p2);
        }
        const [a1, b1] = this.generalForm;
        const [a2, b2] = line.generalForm;
        return mathzz_1.TMath.eq(a1 * b2, a2 * b1) && mathzz_1.TMath.eq(a1 * a2, -b1 * b2);
    }
    sign(p) {
        const [a, b, c] = this.generalForm;
        return Math.sign(a * p.x + b * p.y + c);
    }
    get length() {
        const { x: x1, y: y1 } = this.p1;
        const { x: x2, y: y2 } = this.p2;
        return Math.hypot(x2 - x1, y2 - y1);
    }
}
exports.Line = Line;
//# sourceMappingURL=Line.js.map