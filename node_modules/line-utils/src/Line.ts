import { Point, PointDef } from "./Point";
import { rlerp, TMath } from "mathzz";

export interface LineDef {
  p1: PointDef;
  p2: PointDef;
}

export class Line implements LineDef {
  p1: Point;
  p2: Point;

  constructor(p1: PointDef, p2: PointDef);
  constructor(line: LineDef);
  constructor(p1: PointDef | LineDef, p2?: PointDef) {
    if (p2 === undefined) {
      this.p1 = new Point((p1 as LineDef).p1);
      this.p2 = new Point((p1 as LineDef).p2);
    } else {
      this.p1 = new Point(p1 as PointDef);
      this.p2 = new Point(p2);
    }
  }

  get generalForm(): [number, number, number] {
    const a = this.p1.y - this.p2.y;
    const b = this.p2.x - this.p1.x;
    const c = this.p1.x * this.p2.y - this.p2.x * this.p1.y;
    return [a, b, c];
  }

  lerp(t: number): Point {
    return this.p1.lerpTo(this.p2, t);
  }

  rlerp(p: PointDef): number | null {
    const tx = rlerp(this.p1.x, this.p2.x, p.x);
    const ty = rlerp(this.p1.y, this.p2.y, p.y);
    if (tx === null || ty === null) {
      return null;
    }
    if (!TMath.eq(tx, ty)) {
      return null;
    }
    return tx;
  }

  intersectsAt(line: LineDef): Point | null {
    if (!(line instanceof Line)) {
      line = new Line(line.p1, line.p2);
    }

    const [a1, b1, c1] = this.generalForm;
    const [a2, b2, c2] = (line as Line).generalForm;
    const det = a1 * b2 - a2 * b1;
    if (TMath.eq(det, 0)) {
      return null;
    }
    const x = (b1 * c2 - b2 * c1) / det;
    const y = (c1 * a2 - c2 * a1) / det;
    return new Point(x, y);
  }

  intersects(line: LineDef): boolean {
    return !!this.intersectsAt(line);
  }

  intersectsAtTime(line: LineDef): number | null {
    const intersection = this.intersectsAt(line);
    if (!intersection) {
      return null;
    }
    return this.rlerp(intersection);
  }

  isExtensionOf(line: LineDef): boolean {
    if (!(line instanceof Line)) {
      line = new Line(line.p1, line.p2);
    }

    const [a1, b1, c1] = this.generalForm;
    const [a2, b2, c2] = (line as Line).generalForm;
    return (
      TMath.eq(a1 * b2, a2 * b1) &&
      TMath.eq(a1 * c2, a2 * c1) &&
      TMath.eq(b1 * c2, b2 * c1)
    );
  }

  isParallelTo(line: LineDef): boolean {
    if (!(line instanceof Line)) {
      line = new Line(line.p1, line.p2);
    }

    const [a1, b1] = this.generalForm;
    const [a2, b2] = (line as Line).generalForm;
    return TMath.eq(a1 * b2, a2 * b1);
  }

  isPerpendicularTo(line: LineDef): boolean {
    if (!(line instanceof Line)) {
      line = new Line(line.p1, line.p2);
    }

    const [a1, b1] = this.generalForm;
    const [a2, b2] = (line as Line).generalForm;
    return TMath.eq(a1 * a2, -b1 * b2);
  }

  isCollinearTo(line: LineDef): boolean {
    if (!(line instanceof Line)) {
      line = new Line(line.p1, line.p2);
    }

    const [a1, b1] = this.generalForm;
    const [a2, b2] = (line as Line).generalForm;
    return TMath.eq(a1 * b2, a2 * b1) && TMath.eq(a1 * a2, b1 * b2);
  }

  isConcurrentTo(line: LineDef): boolean {
    if (!(line instanceof Line)) {
      line = new Line(line.p1, line.p2);
    }

    const [a1, b1] = this.generalForm;
    const [a2, b2] = (line as Line).generalForm;
    return TMath.eq(a1 * b2, a2 * b1) && TMath.eq(a1 * a2, -b1 * b2);
  }

  sign(p: PointDef): number {
    const [a, b, c] = this.generalForm;
    return Math.sign(a * p.x + b * p.y + c);
  }

  get length(): number {
    const { x: x1, y: y1 } = this.p1;
    const { x: x2, y: y2 } = this.p2;
    return Math.hypot(x2 - x1, y2 - y1);
  }
}
