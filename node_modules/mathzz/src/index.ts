export * from "./degTrig";
export * from "./tolerantMath";

export function lerp(a: number, b: number, t: number): number {
  return a + (b - a) * t;
}

export function rlerp(a: number, b: number, n: number): number {
  return (n - a) / (b - a);
}

export function clamp(value: number, min: number, max: number): number {
  return value < min ? min : value > max ? max : value;
}

export function wrap(value: number, min: number, max: number): number {
  const range = max - min;
  if (range <= 0) {
    return 0;
  }
  let res = (value - min) % range;
  if (res < 0) {
    res += range;
  }
  return res + min;
}

export function map(
  value: number,
  inMin: number,
  inMax: number,
  outMin: number,
  outMax: number
): number {
  return lerp(outMin, outMax, rlerp(inMin, inMax, value));
}

export function random(
  min: number,
  max: number,
  method: "ROUND" | "FLOOR" | "CEIL" | null = null
): number {
  const res = Math.random() * (max - min) + min;
  if (method === "ROUND") {
    return Math.round(res);
  }
  if (method === "FLOOR") {
    return Math.floor(res);
  }
  if (method === "CEIL") {
    return Math.ceil(res);
  }
  return res;
}

export function positiveModulo(value: number, whole: number) {
  return ((value % whole) + whole) % whole;
}

export function sum(...n: number[]): number {
  return n.reduce((a, b) => a + b, 0);
}

export function ceilRegardlessSign(value: number): number {
  return Math.ceil(Math.abs(value)) * Math.sign(value);
}

export function floorRegardlessSign(value: number): number {
  return Math.floor(Math.abs(value)) * Math.sign(value);
}

export function roundRegardlessSign(value: number): number {
  return Math.round(Math.abs(value)) * Math.sign(value);
}
